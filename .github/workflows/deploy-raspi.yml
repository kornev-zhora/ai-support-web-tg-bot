name: Deploy to Raspberry Pi (Self-Hosted)

on:
  repository_dispatch:
    types: [deploy-to-raspi] # Запускається після успішної збірки та push

jobs:
  deploy:
    runs-on: [self-hosted, linux, raspi-deploy] # Використовуємо ваш Raspberry Pi Runner
    environment: raspberry
    steps:
      - name: 1. Get Image Tag from Payload
        # Отримуємо тег образу, який щойно був зібраний (використовуємо SHA коміту)
        id: get_tag
        run: |
          IMAGE_TAG=$(jq --raw-output .client_payload.image_tag "$GITHUB_EVENT_PATH")
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
        env:
          # Встановіть jq, якщо його немає на вашому Pi: sudo apt install jq
          # Це дозволяє парсити JSON, що передається
          DEBIAN_FRONTEND: noninteractive

      - name: 2. Login to Docker Hub
        # Потрібен для отримання приватного образу
        run: docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}

      - name: 3. Pull and Stop Old Container
        # Отримання нового образу та зупинка старого контейнера
        run: |
          IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/ai-support-bot

          # 3.1. Отримання нового образу
          docker pull $IMAGE_NAME:${{ env.IMAGE_TAG }}

          # 3.2. Зупинка старого контейнера (якщо існує)
          CONTAINER_ID=$(docker ps -aq --filter "name=ai-support-bot")
          if [ ! -z "$CONTAINER_ID" ]; then
            docker stop $CONTAINER_ID
            docker rm $CONTAINER_ID
          fi

          # 3.3. Видалення старих образів
          docker image prune -f

      - name: 4. Run New Container
        run: |
          IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/ai-support-bot

          # Run container with environment variables from GitHub Environment
          docker run -d \
          --name ai-support-bot \
          --restart unless-stopped \
          -p ${{ vars.APP_PORT || 80 }}:80 \
          -e APP_NAME="${{ vars.APP_NAME || 'AI Support Bot' }}" \
          -e APP_ENV=production \
          -e APP_DEBUG=false \
          -e APP_KEY="${{ secrets.APP_KEY }}" \
          -e APP_URL="${{ vars.APP_URL }}" \
          -e APP_PORT=80 \
          -e DB_CONNECTION="${{ vars.DB_CONNECTION || 'sqlite' }}" \
          -e DB_DATABASE="${{ vars.DB_DATABASE || '/var/www/html/database/database.sqlite' }}" \
          -e LOG_CHANNEL="${{ vars.LOG_CHANNEL || 'stack' }}" \
          -e LOG_LEVEL="${{ vars.LOG_LEVEL || 'error' }}" \
          -e SESSION_DRIVER="${{ vars.SESSION_DRIVER || 'file' }}" \
          -e CACHE_STORE="${{ vars.CACHE_STORE || 'file' }}" \
          -e QUEUE_CONNECTION="${{ vars.QUEUE_CONNECTION || 'sync' }}" \
          -e GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}" \
          -e GEMINI_MODEL="${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}" \
          -e TELEGRAM_TOKEN="${{ secrets.TELEGRAM_TOKEN }}" \
          -e VITE_TELEGRAM_BOT_USERNAME="${{ vars.TELEGRAM_BOT_USERNAME }}" \
          -e TELEGRAPH_BOT_NAME="${{ vars.TELEGRAM_BOT_USERNAME }}" \
          -e TELEGRAPH_TOKEN="${{ secrets.TELEGRAM_TOKEN }}" \
          -e TELEGRAPH_WEBHOOK_URL="${{ vars.TELEGRAPH_WEBHOOK_URL }}" \
          -e MAIL_MAILER="${{ vars.MAIL_MAILER || 'log' }}" \
          $IMAGE_NAME:${{ env.IMAGE_TAG }}

      - name: 5. Deployment Completed on Raspberry Pi
        run: echo "Successfully deployed tag ${{ env.IMAGE_TAG }} on Raspberry Pi."