name: Deploy to Raspberry Pi (Self-Hosted)

on:
  repository_dispatch:
    types: [deploy-to-raspi] # Запускається після успішної збірки та push

jobs:
  deploy:
    runs-on: [self-hosted, linux, raspi-deploy] # Використовуємо ваш Raspberry Pi Runner
    environment: raspberry
    steps:
      - name: 1. Get Image Tag from Payload
        # Отримуємо тег образу, який щойно був зібраний (використовуємо SHA коміту)
        id: get_tag
        run: |
          IMAGE_TAG=$(jq --raw-output .client_payload.image_tag "$GITHUB_EVENT_PATH")
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
        env:
          # Встановіть jq, якщо його немає на вашому Pi: sudo apt install jq
          # Це дозволяє парсити JSON, що передається
          DEBIAN_FRONTEND: noninteractive

      - name: 2. Clean Workspace
        # Fix permissions on storage directories before checkout to prevent EACCES errors
        run: |
          if [ -d "$GITHUB_WORKSPACE/storage" ]; then
            chmod -R u+w "$GITHUB_WORKSPACE/storage" || true
            rm -rf "$GITHUB_WORKSPACE/storage" || true
          fi

      - name: 3. Checkout Repository
        uses: actions/checkout@v4

      - name: 4. Login to Docker Hub
        # Потрібен для отримання приватного образу
        run: docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}

      - name: 5. Pull and Stop Old Container
        # Отримання нового образу та зупинка старого контейнера
        run: |
          IMAGE_NAME=${{ secrets.DOCKER_USERNAME }}/ai-support-bot

          # 5.1. Отримання нового образу
          docker pull $IMAGE_NAME:${{ env.IMAGE_TAG }}

          # 5.2. Зупинка старого контейнера (якщо існує)
          CONTAINER_ID=$(docker ps -aq --filter "name=ai-support-bot")
          if [ ! -z "$CONTAINER_ID" ]; then
            docker stop $CONTAINER_ID
            docker rm $CONTAINER_ID
          fi

          # 5.3. Видалення старих образів
          docker image prune -f

      - name: 6. Deploy with Docker Compose
        run: |
          # Create environment file (output hidden for security)
          {
            echo "APP_NAME=\"${{ vars.APP_NAME || 'AI Support Bot' }}\""
            echo "APP_ENV=production"
            echo "APP_DEBUG=false"
            echo "APP_KEY=\"${{ secrets.APP_KEY }}\""
            echo "APP_URL=\"${{ vars.APP_URL }}\""
            echo "APP_PORT=${{ vars.APP_PORT || 8060 }}"
            echo "WWWUSER=${{ vars.WWWUSER || 1000 }}"
            echo "WWWGROUP=${{ vars.WWWGROUP || 1000 }}"
            echo ""
            echo "DB_CONNECTION=pgsql"
            echo "DB_HOST=${{ vars.DB_HOST || 'localhost' }}"
            echo "DB_PORT=${{ vars.DB_PORT || '5432' }}"
            echo "DB_DATABASE=${{ vars.DB_DATABASE || 'ai-bot' }}"
            echo "DB_USERNAME=${{ secrets.DB_USERNAME }}"
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}"
            echo ""
            echo "REDIS_HOST=${{ vars.REDIS_HOST || 'localhost' }}"
            echo "REDIS_PORT=${{ vars.REDIS_PORT || '6379' }}"
            echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}"
            echo ""
            echo "GEMINI_API_KEY=\"${{ secrets.GEMINI_API_KEY }}\""
            echo "GEMINI_MODEL=\"${{ vars.GEMINI_MODEL || 'gemini-2.5-flash' }}\""
            echo "TELEGRAM_TOKEN=\"${{ secrets.TELEGRAM_TOKEN }}\""
            echo "TELEGRAM_BOT_USERNAME=\"${{ vars.TELEGRAM_BOT_USERNAME }}\""
            echo "TELEGRAPH_WEBHOOK_URL=\"${{ vars.TELEGRAPH_WEBHOOK_URL || '' }}\""
            echo ""
            echo "DOCKER_IMAGE=${{ secrets.DOCKER_USERNAME }}/ai-support-bot:${{ env.IMAGE_TAG }}"
          } > .env 2>&1
          echo "✓ Environment file created"

          # Copy override file and start services
          cp compose.override.raspberry.yml compose.override.yml

          # Start only ai-support-bot service without dependencies (pgsql, redis are external)
          # --no-deps prevents trying to start pgsql and redis from base compose.yaml
          # --remove-orphans cleans up any old services
          docker compose up -d --no-deps ai-support-bot --remove-orphans

          # Wait for container to be fully up
          echo "Waiting for container to start..."
          for i in {1..30}; do
            if docker exec ai-support-bot test -f /var/www/html/artisan; then
              echo "Container is ready"
              break
            fi
            echo "Attempt $i/30: Waiting..."
            sleep 2
          done

          # Ensure storage directories have correct permissions
          docker exec ai-support-bot chown -R sail:sail /var/www/html/storage
          docker exec ai-support-bot chmod -R 775 /var/www/html/storage

      - name: 7. Run Database Migrations and Cache
        run: |
          # Clear and optimize caches
          docker exec ai-support-bot php artisan config:clear || true
          docker exec ai-support-bot php artisan cache:clear || true
          docker exec ai-support-bot php artisan route:clear || true
          docker exec ai-support-bot php artisan view:clear || true

          # Run migrations
          docker exec ai-support-bot php artisan migrate --force

          # Optimize for production
          docker exec ai-support-bot php artisan config:cache
          docker exec ai-support-bot php artisan route:cache
          docker exec ai-support-bot php artisan view:cache

      - name: 8. Verify Deployment
        run: |
          echo "=== Container Status ==="
          docker ps --filter "name=ai-support-bot"

          echo ""
          echo "=== Application Health ==="
          docker exec ai-support-bot php artisan --version || echo "Laravel not responding"

          echo ""
          echo "✅ Successfully deployed tag ${{ env.IMAGE_TAG }} on Raspberry Pi"
